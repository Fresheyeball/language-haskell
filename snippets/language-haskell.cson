'.source.haskell':
  'Definition':
    'prefix': '='
    'body': '${1:name} ${2:pattern} = ${0:definition}'
  'Function':
    'prefix': 'fun'
    'body': '''
      ${1:name} :: ${2:Type}
      ${1} ${3:pattern} = ${4:definition}
      '''
  '#!/usr/bin/env…':
    'prefix': '#!'
    'body': '#!/usr/bin/env ${1:runhaskell}\n'
  'Lambda Expression':
    'prefix': '\\'
    'body': '\\${1:pattern} -> ${0:expression}'
  'Left Arrow':
    'prefix': '<'
    'body': '${1:name} <- ${0:expression}'
  'Main':
    'prefix': 'main'
    'body': '''
      module Main where

      main :: IO ()
      main = ${0:putStrLn "Hello World"}\n
      '''
  'Right Arrow':
    'prefix': '>'
    'body': '${1:expression} -> ${0:expression}'
  'Type Signature':
    'prefix': '::'
    'body': '${1:name} :: ${0:Type}'
  'case … of …':
    'prefix': 'case'
    'body': '''
      case ${1:expression} of
      \t${2:pattern} -> ${3:expression}
      \t${4:otherwise} -> ${5:expression}
      '''
  'class …':
    'prefix': 'cla'
    'body': '''
      class ${1:Class} where
      \t${0:definition}
      '''
  'data …':
    'prefix': 'dat'
    'body': 'data ${1:Type} = ${0:Other}'
  'do …':
    'prefix': 'do'
    'body': '''
      do
      \t${1:return ${0:expression}}
      '''
  'if … then … else …':
    'prefix': 'if'
    'body': '''
      if ${1:condition}
      \tthen ${2:expression}
      \telse ${3:expression}
      '''
  'import … hiding …':
    'prefix': 'imph'
    'body': 'import ${1:Module} hiding (${2:function})'
  'import …':
    'prefix': 'imp'
    'body': 'import ${1:Module}'
  'import qualified …':
    'prefix': 'impq'
    'body': 'import qualified ${1:Module}${2: as ${3:Mod}}'
  'instance …':
    'prefix': 'ins'
    'body': '''
      instance ${1:Class} ${2:Type} where
      \t${0:definition}
      '''
  'let …':
    'prefix': 'let'
    'body': '''
      let
      \t${1:name} = ${2:expression}\n\tin ${0:expression}
      '''
  'newtype …':
    'prefix': 'new'
    'body': 'newtype ${1:Type} = ${0:Other}'
  'type …':
    'prefix': 'typ'
    'body': 'type ${1:Type} = ${0:Other}'
  'where …':
    'prefix': 'where'
    'body': '''
      where
      \t${0:definitions}
      '''
'.source.haskell:not(.comment)':
  'Guard':
    'prefix': '|'
    'body': '| ${1:predicate} = ${0:definition}'
'.source.haskell .comment.block':
  'Haddock Postfix':
    'prefix': '|'
    'body': '| ${0:documentation}'
  'Haddock Prefix':
    'prefix': '^'
    'body': '^ ${0:documentation}'
'.source.haskell .constant.language.nil':
  'List Comprehension':
    'prefix': '['
    'body': '[ ${1:expression} | ${2:${3:name} <- ${4:expression}}$0]'
'.source.haskell .meta.function.type':
  'Type Constraint':
    'prefix': '='
    'body': '(${1:Class}) => $0'
'.source.haskell .meta.type':
  'deriving …':
    'prefix': 'der'
    'body': 'deriving (${0:Class})'
